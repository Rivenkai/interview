### 操作系统

- **物理内存和虚拟内存区别**

  物理内存就是CPU的地址线可以直接进行寻址的内存空间大小， 32位的386以上CPU就可以支持最大4GB的物理内存空间。

  虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，当内存占用完时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。比如说当电脑要读取一个比物理内存还要大的文件时，就要用到虚拟内存，文件被内存读取之后就会先储存到虚拟内存，等待内存把文件全部储存到虚拟内存之后，就把虚拟内里储存的文件释放到原来的目录里了。

- **物理地址和虚拟地址区别**

  进程访问的是虚拟地址，32位系统的寻址空间是4GB, 每个进程都拥有4GB的虚拟地址空间，高位的1GB是kernel space, 低位的3GB是user space，通过MMU将虚拟地址映射到物理地址。

  

- **为什么要用虚拟地址**

  - 因为物理内存是有限的，当有多个进程要执行的时候，对每个进程都要分配4G内存，很显然你内存若小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的。

  由于指令都是直接访问物理内存的，那么进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的。

  因为内存是随机分配的，所以程序运行的地址也是不正确的



- **如果只有2gb内存，有一个4gb大小的程序，怎么运行？**

  正在运行的一个进程，他所需的内存是有可能大于内存条容量之和的，比如你的内存条是256M，你的程序却要创建一个2G的数据区，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，在通过调度进入物理内存。所以，虚拟内存是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。有的地方呢，也叫这个虚拟内存为内存交换区。关键的是不要把虚拟内存跟真实的插在主板上的内存条相挂钩，虚拟内存它是“虚拟的”不存在，假的啦，它只是内存管理的一种抽象！

(接上一题)如果不使用虚拟内存，能不能运行成功？为什么能运行成功，怎么做到的？



- **进程访问地址的过程**
  1. 进程每次要访问地址空间上的某一个地址时，都需要把虚拟地址翻译为实际物理内存地址
  2. 进程需要知道哪些虚拟内存地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），若在物理内存上存在，则需要进一步知道数据存储在物理内存上的具体位置，这都需要通过页表来记录。
  3. 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。
  4. 当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常。
  5. 缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。
- <img src="https://upload-images.jianshu.io/upload_images/7111776-be87852c9726bcbc.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:80%;" />



- **介绍一下协程**

  协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。

  协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。

  协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

  协程的好处：

  1. 无需线程上下文切换的开销
  2. 无需原子操作锁定及同步的开销
  3. 方便切换控制流，简化编程模型

  

  高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

- **僵尸进程是什么**

  正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

  **僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**

  

  **任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

  

  僵尸进程危害场景：

  　　例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，**系统中就会存在很多的僵死进程**，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。**枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管**，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。

  

- **对虚拟内存的理解，虚拟内存的大小，页映射的原理**

  当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射关系（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去访问页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。

  另外在进程运行过程中，通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

  可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）



- **进程调度算法**



- **并行并发工作原理**

  并发： 

  在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序		     在CPU上运行。

  CPU的运行时间会被划分成若干个时间段，每个时间段分配给各个线程去执行，一个时间段里某个线程    运行时，其他线程处于挂起状态，这就是并发。**并发解决了程序排队等待的问题**，如果一个程序发生阻塞，其他程序仍然可以正常执行。

  

  并行：  

  当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资         源，可以同时进行，这种方式成为并行。



- **进程与线程区别**

  1. 进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。
  2.  进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。
  3.  线程的调度与切换比进程快很多。

  

-  2、线程同步的方式：互斥锁、自旋锁、读写锁、条件变量
   3、互斥锁与自旋锁的底层区别
   4、孤儿进程与僵尸进程
   5、死锁及避免
   6、多线程与多进程比较
   7、进程间通信：PIPE、FIFO、消息队列、信号量、共享内存、socket
   8、管道与消息队列对比
   9、fork进程的底层：读时共享，写时复制
   10、线程上下文切换的流程
   11、进程上下文切换的流程
   12、进程的调度[算法]()
   13、阻塞IO与非阻塞IO
   14、同步与异步的概念
   15、静态链接与动态链接的过程
   16、虚拟内存概念（非常重要）
   17、MMU地址翻译的具体流程
   18、缺页处理过程
   19、缺页置换[算法]()：最久未使用[算法]()、先进先出[算法]()、最佳置换[算法]()





#### 计算机网络

从上向下架构：应用层、运输层、网络层、链路层、物理层
 链路层：
 3、MTU
 4、MAC地址
 网络层：
 5、地址解析协议
 6、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？
 7、网络层转发数据报的流程
 8、子网划分、子网掩码
 9、网络控制报文协议ICMP
 10、ICMP应用举例：PING、traceroute
 运输层：
 11、TCP与UDP的区别及应用场景
 12、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）
 13、TCP滑动窗口原理
 14、TCP超时重传时间选择
 15、TCP流程控制
 16、TCP拥塞控制（一定要弄清楚与流量控制的区别）
 17、TCP三次握手及状态变化。为啥不是两次握手？
 18、TCP四次挥手及状态变化。为啥不是三次挥手？
 19、TCP连接释放中TIME_WAIT状态的作用
 20、SYN泛洪攻击。如何解决？
 21、TCP粘包
 22、TCP心跳包
 23、路由器与交换机的区别
 24、UDP如何实现可靠传输
 应用层：
 25、DNS域名系统。采用TCP还是UDP协议？为什么？
 26、FTP协议（了解）
 27、HTTP请求报文与响应报文首部结构
 28、HTTP1.0、HTTP1.1、HTTP2.0对比
 29、HTTP与HTTPS对比
 30、HTTPS加密流程
 31、方法：GET、HEAD、POST、PUT、DELETE
 32、状态码：1**、2**、3**、4**、5**
 33、cookie与session区别
 34、输入一个URL到显示页面的流程（越详细越好，搞明白这个，网络这块就差不多了）



1、IO多路复用：select、poll、epoll的区别（非常重要，几乎必问，回答得越底层越好，要会使用）
 2、手撕一个最简单的server端服务器（socket、bind、listen、accept这四个API一定要非常熟练）
 3、线程池
 4、基于事件驱动的reactor模式
 5、边沿触发与水平触发的区别
 6、非阻塞IO与阻塞IO区别