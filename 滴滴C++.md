### C++基础

#### 指针和引用

#### 动态多态和静态多态

也称编译期多态 和 运行期多态

动态多态： 基类里声明虚函数接口，各个子类再重写这些虚函数。通过指向基类的引用或者指针来操作对象，对虚函数的调用会自动绑定到实际的子类对象上。在运行时确定

静态多态：函数重载，泛型编程，在编译时确定

#### 虚函数工作原理

C++中虚函数的实现一般是通过虚函数表实现的。

类的虚函数表是一块连续的内存，每个内存单元中记录一个虚函数的地址。**编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。** 类的每个虚成员占据虚函数表中的一行。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。

在有虚函数的类的对象中分配了指向这个表的指针的内存（虚函数指针）（**位于对象实例的最前面**）

到这里，你是否已经明白为什么指向子类实例的基类指针可以调用子类（虚）函数？每一个实例对象中都存在一个vfptr指针，编译器会先取出vfptr的值，这个值就是虚函数表vftable的地址，再根据这个值来到vftable中调用目标函数。所以，只要vfptr不同，指向的虚函数表vftable就不同，而不同的虚函数表中存放着对应类的虚函数地址，这样就实现了多态的”效果“。

- 虚函数表存放的内容：类的虚函数的地址
- 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。
- 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。

#### 什么是纯虚函数

虚函数在类中声明时，加上 =0， 不实现其虚函数。含有纯虚函数的类称为抽象类，类中只有接口，没有具体的实现方法；

抽象类对象不能作为函数的参数，不能创建对象。

#### 虚表指针和虚函数表的存放位置

虚表指针在对象的最前面，对象时动态分配的，在堆中分配内存，因此，**虚表指针在堆中**

虚函数表：

- *虚函数表是全局共享的元素**,**即全局仅有一个*
- *虚函数表不是函数**,**不是程序代码**,**不肯能存储在代码段*
- *虚函数表的大小可以确定**,**即大小是在编译时期确定的**,**不必动态分配内存空间存储虚函数表**,**所以不再堆中*
- *根据以上特征**,**虚函数表存储在全局数据区（静态区）类似于类中静态成员变量**.**静态成员变量也是全局共享**,**大小确定**.*

##### 什么是智能指针，有哪些，实现原理

智能指针是模板类，对普通指针的一种封装，封装成一个智能指针类，在构造函数的传入一个普通指针，在析构的时候释放

智能指针的作用是防止忘记调用delete释放内存，或者多次释放同一个指针造成程序崩溃

shared_ptr, unique_ptr, weak_ptr

shared_ptr:  多个指针指向相同的对象。shared_ptr使用引用计数, 每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。  shared_ptr的最大陷阱是循环引用，会导致堆内存无法正确释放，导致内存泄漏

unique_ptr: 同一时刻只能有一个unique_ptr指向给定的对象，unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁

weak_ptr:  weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和->,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权. 

**如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放**



##### 解决循环引用

即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄露。

**1**. 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。

**2**. 当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A

**3**. 使用弱引用的智能指针打破这种循环引用。 weak_ptr

一个强引用当被引用的对象活着的话，这个引用也存在（就是说，当至少有一个强引用，那么这个对象就不能被释放）。share_ptr就是强引用。相对而言，弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。



#### C++内存管理

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区

- **栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
- **堆**：动态申请的内存空间，就是由 `malloc` 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。
- 全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
- **常量存储区**（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。
- **代码区**（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env



#### 函数的调用机制

（1）建立栈空间；
（2）保护现场：主调函数运行状态和返回地址入栈；
（3）为被调函数中的局部变量分配空间，完成参数传递，参数从右往左入栈；

（4）跳转到被调用的函数地址，执行被调函数函数体；
（5）释放被调函数中局部变量占用的栈空间；
（6）回复现场：取主调函数运行状态及返回地址，释放栈空间；
（7）继续主调函数后续语句。



#### C++11 新特性

- “语法糖”：`nullptr`, `auto`自动类型推导，范围for循环，初始化列表, lambda表达式等
- 右值引用和移动语义
- 智能指针
- C++11多线程编程：`thread`库及其相配套的同步原语`mutex`, `lock_guard`, `condition_variable`, 以及异步`std::furture`



##### 深拷贝与浅拷贝

 C++ 中，默认对象之间的拷贝（包括默认复制构造函数和默认赋值语句）是浅拷贝

浅拷贝就是逐个字节的拷贝。也就是说，拷贝后每一个成员变量的值都相同。如果该值是基本数据类型，那么该值被拷贝；如果该值是引用数据类型（如对象、指针等），那么该值（注意：这里的值是指**地址**）也会被拷贝。

一句话：**浅拷贝会共享引用数据类型成员变量（指针指向同一个地址），而不共享原始数据类型的成员变量**

有时候，我们并不希望拷贝对象时，其引用成员变量指向同一个引用数据类型的数据对象，而希望它们指向不同的位置，但是这些位置存储的值是相同的。这就需要用到深拷贝。

- 浅拷贝会**共享**引用数据类型成员变量（指针指向**同一个地址**），而**不共享**原始数据类型的成员变量
- 深拷贝**不会共享**引用数据类型成员变量（它们的指针指向**不同**地址，但是拷贝后指针指向地址所存储的**值是相等的**），也**不共享**原始数据类型的成员变量
- 在 C++ 中可以**自定义复制构造函数**、**重载赋值运算符**，**实现深拷贝**



##### i++是原子操作吗

不是原子操作。理由：

**1.i++分为三个阶段：**

内存到寄存器
寄存器自增
写回内存
这三个阶段中间都可以被中断分离开

```
在多线程场景中可以使用原子整型(AtomicInteger)
```



##### C++类对象从编写代码定义到生成可执行文件的全过程描述



##### 类对象的内存分布与生存周期

对于静态内存中存储的局部static对象、类static数据成员以及定义在任何函数之外的变量，全局对象(任何函数之外的对象)在程序启动时分配，在程序结束时销毁；

对于局部static对象、类static对象在第一次使用前分配内存，在程序结束时销毁。

对于栈内存，用来保存定义在函数内的非static对象。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁，分配在静态或栈内存中的对象由编译器自动创建和销毁。

对于堆内存。程序用堆来存储动态分配的对象(程序运行时分配的对象)。动态内存管理是通过一对运算符来完成的：new在动态内存中为对象分配空间并返回一个指向该内存对象的指针；delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。



### 计算机网络

#### TCP的报文首部结构

<img src="https://upload-images.jianshu.io/upload_images/2906649-6967dcab99ff2804.png?imageMogr2/auto-orient/strip|imageView2/2/w/887/format/webp" alt="img" style="zoom: 67%;" />

源端口： 16位

目的端口： 16位

序列号： 32位

确认号： 32位

数据偏移： 4位

保留位： 6位 （URG, ACK, PSH, RST, SYN, FIN）

窗口大小：16位

校验和：

紧急指针：



#### UDP首部结构

源端口 16位

目的端口 16位

长度 16位

校验和 16位



#### TCP与UDP区别

- 基于有链接和无连接
- 对系统资源的要求（TCP较多，UDP较少
- UDP程序结构简单
- 流模式与数据报模式
- TCP保证数据正确性，UDP可能丢包
- TCP保证数据顺序，UDP不保证



#### TCP如何保证可靠性

- 数据分块
- 序列号和确认应答：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。
- 校验和：  TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。
- 流量控制： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。
- 拥塞控制：当网络某个节点发生拥塞时，减少数据的发送。
- ARQ协议：为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
- 超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。

#### time_wait为什么等待2msl

当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长

客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。



#### time_wait过多怎么解决

我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。

解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。也可以采用长连接的方式减少 TCP 的连接与断开



#### Fin_wait2状态

出现fin_wait_2一般为客户端，如果为服务端出现，则表明是服务端主动发起的断开

主动一方发起FIN报文，只要对端发送ACK确认后主动方就会处于FIN_WAIT2状态，然后等待对端发送FIN报文，如果一直没有发送FIN报文（就会一直处于CLOSE_WAIT状态，还有数据要发送，等等再关闭），那么主动一方就可能永远处于FIN_WAIT2状态

为了解决主动一方永远处于FIN_WAIT2状态，操作系统设置了一个定时器，如果这个连接空闲时间超时了，那么该连接将进入CLOSED状态。



#### 拥塞控制算法

- 慢启动

当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd为 1，即一开始发送一个报文段。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 cwnd = cwnd* 2

但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个慢开始门限 ssthresh。

① 当 cwnd < ssthresh 时，使用上述的慢开始算法；

② 当 cwnd > ssthresh 时，停止使用慢开始，转而使用拥塞避免算法；

③ 当 cwnd == ssthresh 时，两者均可。



- 拥塞避免

拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态。

当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。

- 快重传

快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。

- 快恢复

快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：

① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；

② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。



#### 流量控制和拥塞控制区别

- 流量控制：

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

- 拥塞控制

除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。

- **拥塞控制和流量控制的区别**

拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。



### 数据结构

#### map和unordered_map 的区别

map是基于红黑树实现，作为一种自平衡二叉树，保证了良好的最坏情况运行时间，即可以做到在O（logn）时间内完成查找插入和删除。

unordered_map是基于hash_table实现，一般是由一个大的vector，vector元素节点挂链表来解决冲突来实现。 哈希表的最大的有点，就是把数据的存储和消耗的时间大大降低，常数时间。代价是消耗较多的内存，用空间换时间。

**综上，抛出结论，在需要有序性或者对单次查询有时间要求的应用场景下，应使用map，其余情况应使用unordered_map。**



#### 二叉搜索树 （Binary Search Tree， BST）

基本性质：

1.定义空树是一颗二叉查找树

2.左子树节点的所有节点的值都小于根节点的值。

3.右子树所有节点的值都大于根节点的值。

4.左右子树都是BST（递归定义）

5.中序遍历是升序。

#### 平衡二叉树（AVL）

平衡二叉树，其实就是在二叉排序树创建过程中保证它的平衡性，一旦发现有不平衡的情况，马上处理，这样就不会造成不可收拾的情况出现。然后通过上面的平衡手段，我们发现，当最小不平衡子树根节点的BF大于1时，就右旋，小于-1时就左旋。当最小不平衡子树的BF与它的子树的BF符号相反时，就需要对节点先进行一次旋转以使得符号相同后，再反向旋转一次才能完成平衡操作。

查找，插入，删除的时间复杂度都为O（logn）

#### 红黑树

- 是一颗二叉排序树（BST,binary sort tree）
- 每个节点要么是黑的，要么是红的
- 根节点是黑的，并定义NULL为黑色
- 如果一个节点是红色，那么他的两个子节点必定是黑色，父亲也是黑色
- 对每个节点，它到叶节点的每一个路径都包含相同数目的黑色节点

隐含特征：

1.任意一颗以黑色节点为根的子树也必定是一颗红黑树。（递归定义）

2.左（右）子树的高度最多是右（左）子树高度的两倍。即若H(left)>H(right),H(left)<=2*H(right)+1（所以，红黑树并不是平衡的！！！）

红黑树的自调整：变色，左旋，右旋



红黑树就是吸收了2-3-4树和AVL树的优点，放弃了AVL树完美平衡的特性，改为局部平衡和完美黑色平衡。放弃2-3-4树的多节点，改为使用颜色来区分不同的节点类型。这样就降低了维护的成本和时间复杂度。可以直接使用二叉排序树的查找方法来进行查找操作。



### B树

B树是一种多路自平衡搜索树，它类似普通的二叉树，但是B书允许每个节点有更多的子节点。B树示意图如下：

<img src="https://upload-images.jianshu.io/upload_images/7361383-b4226ba0e306bd27.png?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp" alt="img" style="zoom:67%;" />

B树的特点：

（1）所有键值分布在整个树中

（2）任何关键字出现且只出现在一个节点中

（3）搜索有可能在非叶子节点结束

（4）在关键字全集内做一次查找，性能逼近二分查找算法

### B+树

B+树是B树的变体，也是一种多路平衡查找树，B+树的示意图为：

<img src="https://upload-images.jianshu.io/upload_images/7361383-3e9ef22b51d553c3.png?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp" alt="img" style="zoom:80%;" />

从图中也可以看到，B+树与B树的不同在于：

（1）所有关键字存储在叶子节点，非叶子节点不存储真正的data

（2）为所有叶子节点增加了一个链指针

B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，这不就是文件系统文件的查找吗?

### 为什么用B/B+树这种结构来实现索引呢？？

红黑树等结构也可以用来实现索引，但是文件系统及数据库系统普遍使用B/B+树结构来实现索引。mysql是基于磁盘的数据库，索引是以索引文件的形式存在于磁盘中的，索引的查找过程就会涉及到磁盘IO(为什么涉及到磁盘IO请看文章后面的附加理解部分)消耗，磁盘IO的消耗相比较于内存IO的消耗要高好几个数量级，所以索引的组织结构要设计得在查找关键字时要尽量减少磁盘IO的次数。为什么要使用B/B+树，跟磁盘的存储原理有关。

**局部性原理与磁盘预读**

**局部性原理与磁盘预读**

为了提升效率，要尽量减少磁盘IO的次数。实际过程中，磁盘并不是每次严格按需读取，而是每次都会预读。磁盘读取完需要的数据后，会按顺序再多读一部分数据到内存中，这样做的理论依据是计算机科学中注明的局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用；程序运行期间所需要的数据通常比较集中；由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

（1）由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，

因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。

（2）MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改)。linux 默认页大小为4K。

**B-Tree借助计算机磁盘预读的机制**，并使用如下技巧：

每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。

假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3，也即索引的B+树层次一般不超过三层，所以查找效率很高）

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，**无法利用局部性**，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

#### 为什么mysql的索引使用B+树而不是B树呢？？

（1）B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。

  (2)  mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树每个节点的key和data在一起，无法进行区间查找。

1、 **B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2、**B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

**数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。**



#### 总结：

二叉查找树：

1）查找过程中需要磁盘多次IO；

2）某些情况下会退化为线性表从而变成线性查找



AVL树：

1）查找过程中需要磁盘多次IO；

2）为了维持绝对平衡代价极大；但是相比于二叉查找树不会变成线性查找



红黑树：

1）对于二叉查找树进行平衡。

2）但是沿袭了所有二叉树缺点，查找过程需要多次磁盘IO



B树：

1）只需一次磁盘IO；

2）平衡的，查询效率稳定；

3）高度相对于二叉树极低，因此极大减少了IO磁盘次数 



B+树：

1）B树有点B+树都有；

2）内部节点相对B树更小，一页可以存储更多信息；

3）因为查询路径为根节点到叶子节点，因此查询效率更加稳定；

4）数据都存储在叶子节点，方便扫库，有利于区间查询，因此索引都用B+树实现



### 数据库

#### 数据库索引的作用，应用场景

通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

可以大大加快 数据的检索速度，这也是创建索引的最主要的原因

索引能够使得在查询过程中，使用到数据库的查询优化器，极大提高系统的性能

索引的分类：

按照数据结构和使用的算法划分：

​	B+索引，Hash索引，B-Tree索引

按照类型划分：

普通索引，主键索引，唯一索引，联合索引



#### ACID特性：

事务四大特性：

- 原子性（atomicity）

整个事务中的所有操作要么全部提交成功，要么全部失败回滚,不可能只执行其中的一部分操作

- 一致性（consistency）

数据库总是从一个一致性的状态转换到另一个一致性的状态, 一致性确保了，即使在执行第三、四条语句之间时系统崩溃，前面执行的语句也不会生效。因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。

- 隔离性（isolation）

一个事务所做的修改在最终提交以前，对其他事务是不可见的。当执行完第三条语句、第四条语句还未开始时，此时有另外一个程序开始运行，则看不到第三条语句做出的改变。

- 持久性（durability）

一旦事务提交，则其所做的修改就会永久保存到数据库中。



### 算法

#### 快速排序

```c++
void quickSort(vector<int>& nums, int left, int right) {
    if (left < right) {
        int key = nums[left];
        int i = left;
        int j = right;
        
        while (i < j) {
            while(i < j && nums[i] > key)
                j--;
            
            if (i < j) {
                nums[i] = nums[j];
                i++;
            }
           	
            while (i<j && nums[i] < key) {
                i++;
            }
            if (i < j) {
                nums[j] = nums[i];
                j--;
            }
        }
        nums[i] = key;
        
        quickSort(nums, left, i-1);
        qucikSort(nums, i+1, right);
    }
}
```



#### 实现线程安全的单例模式

单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的**唯一性**。

单例模式可以分为**懒汉式**和**饿汉式**，两者之间的区别在于**创建实例的时间不同**：

- **懒汉式**：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。**（这种方式要考虑线程安全）**
- **饿汉式**：指系统一运行，就初始化创建实例，当需要时，直接调用即可。**（本身就线程安全，没有多线程的问题。 因为静态实例初始化在程序开始时**进入主函数之前就由主线程以单线程方式完成了初始化**，不必担心多线程问题）**

##### 单例类特点

- 构造函数和析构函数为**private**类型，目的**禁止**外部构造和析构
- 拷贝构造和赋值构造函数为**private**类型，目的是**禁止**外部拷贝和赋值，确保实例的唯一性
- 类里有个获取实例的**静态函数**，可以全局访问



##### 懒汉式：

1. 静态成员实例的懒汉模式：

```c++
class Singleton
{
private:
    static Singleton* m_instance;
    Singleton(){}
public:
    static Singleton* getInstance();
};

Singleton* Singleton::getInstance()
{
    if(NULL == m_instance)
    {
        Lock();//借用其它类来实现，如boost
        if(NULL == m_instance)
        {
            m_instance = new Singleton;
        }
        UnLock();
    }
    return m_instance;
}
```

2. 内部静态实例的懒汉模式：

```c++
class SingletonInside
{
private:
    SingletonInside(){}
public:
    static SingletonInside* getInstance()
    {
        Lock(); // not needed after C++0x
        static SingletonInside instance;
        UnLock(); // not needed after C++0x
        return instance;
    }
};
```



饿汉模式：

```c++
class SingletonStatic
{
private:
    static const SingletonStatic* m_instance;
    SingletonStatic(){}
public:
    static const SingletonStatic* getInstance()
    {
        return m_instance;
    }
};

//外部初始化 before invoke main
const SingletonStatic* SingletonStatic::m_instance = new SingletonStatic;
```

