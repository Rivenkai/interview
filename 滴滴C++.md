### C++基础

#### 指针和引用

#### 动态多态和静态多态

也称编译期多态 和 运行期多态

动态多态： 基类里声明虚函数接口，各个子类再重写这些虚函数。通过指向基类的引用或者指针来操作对象，对虚函数的调用会自动绑定到实际的子类对象上。在运行时确定

静态多态：函数重载，泛型编程，在编译时确定

#### 虚函数工作原理

C++中虚函数的实现一般是通过虚函数表实现的。

类的虚函数表是一块连续的内存，每个内存单元中记录一个虚函数的地址。**编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。** 类的每个虚成员占据虚函数表中的一行。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。

在有虚函数的类的对象中分配了指向这个表的指针的内存（虚函数指针）（**位于对象实例的最前面**）

到这里，你是否已经明白为什么指向子类实例的基类指针可以调用子类（虚）函数？每一个实例对象中都存在一个vfptr指针，编译器会先取出vfptr的值，这个值就是虚函数表vftable的地址，再根据这个值来到vftable中调用目标函数。所以，只要vfptr不同，指向的虚函数表vftable就不同，而不同的虚函数表中存放着对应类的虚函数地址，这样就实现了多态的”效果“。

- 虚函数表存放的内容：类的虚函数的地址
- 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。
- 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。

#### 什么是纯虚函数

虚函数在类中声明时，加上 =0， 不实现其虚函数。含有纯虚函数的类称为抽象类，类中只有接口，没有具体的实现方法；

抽象类对象不能作为函数的参数，不能创建对象。

#### 虚表指针和虚函数表的存放位置

虚表指针在对象的最前面，对象时动态分配的，在堆中分配内存，因此，**虚表指针在堆中**

虚函数表：

- *虚函数表是全局共享的元素**,**即全局仅有一个*
- *虚函数表不是函数**,**不是程序代码**,**不肯能存储在代码段*
- *虚函数表的大小可以确定**,**即大小是在编译时期确定的**,**不必动态分配内存空间存储虚函数表**,**所以不再堆中*
- *根据以上特征**,**虚函数表存储在全局数据区（静态区）类似于类中静态成员变量**.**静态成员变量也是全局共享**,**大小确定**.*

##### 什么是智能指针，有哪些，实现原理

智能指针是模板类，对普通指针的一种封装，封装成一个智能指针类，在构造函数的传入一个普通指针，在析构的时候释放

智能指针的作用是防止忘记调用delete释放内存，或者多次释放同一个指针造成程序崩溃

shared_ptr, unique_ptr, weak_ptr

shared_ptr:  多个指针指向相同的对象。shared_ptr使用引用计数, 每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。  shared_ptr的最大陷阱是循环引用，会导致堆内存无法正确释放，导致内存泄漏

unique_ptr: 同一时刻只能有一个unique_ptr指向给定的对象，unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁

weak_ptr:  weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和->,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权. 

**如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放**



##### 解决循环引用

即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄露。

**1**. 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。

**2**. 当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A

**3**. 使用弱引用的智能指针打破这种循环引用。 weak_ptr

一个强引用当被引用的对象活着的话，这个引用也存在（就是说，当至少有一个强引用，那么这个对象就不能被释放）。share_ptr就是强引用。相对而言，弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。



#### C++内存管理

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区

- **栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
- **堆**：动态申请的内存空间，就是由 `malloc` 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。
- 全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
- **常量存储区**（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。
- **代码区**（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env



#### 函数的调用机制

（1）建立栈空间；
（2）保护现场：主调函数运行状态和返回地址入栈；
（3）为被调函数中的局部变量分配空间，完成参数传递，参数从右往左入栈；

（4）跳转到被调用的函数地址，执行被调函数函数体；
（5）释放被调函数中局部变量占用的栈空间；
（6）回复现场：取主调函数运行状态及返回地址，释放栈空间；
（7）继续主调函数后续语句。



#### C++11 新特性

- “语法糖”：`nullptr`, `auto`自动类型推导，范围for循环，初始化列表, lambda表达式等
- 右值引用和移动语义
- 智能指针
- C++11多线程编程：`thread`库及其相配套的同步原语`mutex`, `lock_guard`, `condition_variable`, 以及异步`std::furture`



##### 深拷贝与浅拷贝

 C++ 中，默认对象之间的拷贝（包括默认复制构造函数和默认赋值语句）是浅拷贝

浅拷贝就是逐个字节的拷贝。也就是说，拷贝后每一个成员变量的值都相同。如果该值是基本数据类型，那么该值被拷贝；如果该值是引用数据类型（如对象、指针等），那么该值（注意：这里的值是指**地址**）也会被拷贝。

一句话：**浅拷贝会共享引用数据类型成员变量（指针指向同一个地址），而不共享原始数据类型的成员变量**

有时候，我们并不希望拷贝对象时，其引用成员变量指向同一个引用数据类型的数据对象，而希望它们指向不同的位置，但是这些位置存储的值是相同的。这就需要用到深拷贝。

- 浅拷贝会**共享**引用数据类型成员变量（指针指向**同一个地址**），而**不共享**原始数据类型的成员变量
- 深拷贝**不会共享**引用数据类型成员变量（它们的指针指向**不同**地址，但是拷贝后指针指向地址所存储的**值是相等的**），也**不共享**原始数据类型的成员变量
- 在 C++ 中可以**自定义复制构造函数**、**重载赋值运算符**，**实现深拷贝**



##### i++是原子操作吗

不是原子操作。理由：

**1.i++分为三个阶段：**

内存到寄存器
寄存器自增
写回内存
这三个阶段中间都可以被中断分离开

```
在多线程场景中可以使用原子整型(AtomicInteger)
```



##### C++类对象从编写代码定义到生成可执行文件的全过程描述



##### 类对象的内存分布与生存周期

对于静态内存中存储的局部static对象、类static数据成员以及定义在任何函数之外的变量，全局对象(任何函数之外的对象)在程序启动时分配，在程序结束时销毁；

对于局部static对象、类static对象在第一次使用前分配内存，在程序结束时销毁。

对于栈内存，用来保存定义在函数内的非static对象。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁，分配在静态或栈内存中的对象由编译器自动创建和销毁。

对于堆内存。程序用堆来存储动态分配的对象(程序运行时分配的对象)。动态内存管理是通过一对运算符来完成的：new在动态内存中为对象分配空间并返回一个指向该内存对象的指针；delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。



### 计算机网络

#### TCP的报文首部结构

<img src="https://upload-images.jianshu.io/upload_images/2906649-6967dcab99ff2804.png?imageMogr2/auto-orient/strip|imageView2/2/w/887/format/webp" alt="img" style="zoom: 67%;" />

源端口： 16位

目的端口： 16位

序列号： 32位

确认号： 32位

数据偏移： 4位

保留位： 6位 （URG, ACK, PSH, RST, SYN, FIN）

窗口大小：16位

校验和：

紧急指针：



#### UDP首部结构

源端口 16位

目的端口 16位

长度 16位

校验和 16位



#### TCP与UDP区别

- 基于有链接和无连接
- 对系统资源的要求（TCP较多，UDP较少
- UDP程序结构简单
- 流模式与数据报模式
- TCP保证数据正确性，UDP可能丢包
- TCP保证数据顺序，UDP不保证



#### TCP如何保证可靠性

- 数据分块
- 序列号和确认应答：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。
- 校验和：  TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。
- 流量控制： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。
- 拥塞控制：当网络某个节点发生拥塞时，减少数据的发送。
- ARQ协议：为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
- 超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。

#### time_wait为什么等待2msl

当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长

客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。



#### time_wait过多怎么解决

我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。

解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。也可以采用长连接的方式减少 TCP 的连接与断开



#### Fin_wait2状态

出现fin_wait_2一般为客户端，如果为服务端出现，则表明是服务端主动发起的断开

主动一方发起FIN报文，只要对端发送ACK确认后主动方就会处于FIN_WAIT2状态，然后等待对端发送FIN报文，如果一直没有发送FIN报文（就会一直处于CLOSE_WAIT状态，还有数据要发送，等等再关闭），那么主动一方就可能永远处于FIN_WAIT2状态

为了解决主动一方永远处于FIN_WAIT2状态，操作系统设置了一个定时器，如果这个连接空闲时间超时了，那么该连接将进入CLOSED状态。



#### 拥塞控制算法

- 慢启动

当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd为 1，即一开始发送一个报文段。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 cwnd = cwnd* 2

但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个慢开始门限 ssthresh。

① 当 cwnd < ssthresh 时，使用上述的慢开始算法；

② 当 cwnd > ssthresh 时，停止使用慢开始，转而使用拥塞避免算法；

③ 当 cwnd == ssthresh 时，两者均可。



- 拥塞避免

拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态。

当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。

- 快重传

快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。

- 快恢复

快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：

① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；

② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。



#### 流量控制和拥塞控制区别

- 流量控制：

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

- 拥塞控制

除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。

- **拥塞控制和流量控制的区别**

拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。
