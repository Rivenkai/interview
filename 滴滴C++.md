#### 指针和引用

#### 动态多态和静态多态

也称编译期多态 和 运行期多态

动态多态： 基类里声明虚函数接口，各个子类再重写这些虚函数。通过指向基类的引用或者指针来操作对象，对虚函数的调用会自动绑定到实际的子类对象上。在运行时确定

静态多态：函数重载，泛型编程，在编译时确定

#### 虚函数工作原理

C++中虚函数的实现一般是通过虚函数表实现的。

类的虚函数表是一块连续的内存，每个内存单元中记录一个虚函数的地址。**编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。** 类的每个虚成员占据虚函数表中的一行。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。

在有虚函数的类的对象中分配了指向这个表的指针的内存（虚函数指针）（**位于对象实例的最前面**）

到这里，你是否已经明白为什么指向子类实例的基类指针可以调用子类（虚）函数？每一个实例对象中都存在一个vfptr指针，编译器会先取出vfptr的值，这个值就是虚函数表vftable的地址，再根据这个值来到vftable中调用目标函数。所以，只要vfptr不同，指向的虚函数表vftable就不同，而不同的虚函数表中存放着对应类的虚函数地址，这样就实现了多态的”效果“。

- 虚函数表存放的内容：类的虚函数的地址
- 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。
- 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。

#### 什么是纯虚函数

虚函数在类中声明时，加上 =0， 不实现其虚函数。含有纯虚函数的类称为抽象类，类中只有接口，没有具体的实现方法；

抽象类对象不能作为函数的参数，不能创建对象。

#### 虚表指针和虚函数表的存放位置

虚表指针在对象的最前面，对象时动态分配的，在堆中分配内存，因此，**虚表指针在堆中**

虚函数表：

- *虚函数表是全局共享的元素**,**即全局仅有一个*
- *虚函数表不是函数**,**不是程序代码**,**不肯能存储在代码段*
- *虚函数表的大小可以确定**,**即大小是在编译时期确定的**,**不必动态分配内存空间存储虚函数表**,**所以不再堆中*
- *根据以上特征**,**虚函数表存储在全局数据区（静态区）类似于类中静态成员变量**.**静态成员变量也是全局共享**,**大小确定**.*

##### 什么是智能指针，有哪些，实现原理

智能指针是模板类，对普通指针的一种封装，封装成一个智能指针类，在构造函数的传入一个普通指针，在析构的时候释放

智能指针的作用是防止忘记调用delete释放内存，或者多次释放同一个指针造成程序崩溃

shared_ptr, unique_ptr, weak_ptr

shared_ptr:  多个指针指向相同的对象。shared_ptr使用引用计数, 每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。  shared_ptr的最大陷阱是循环引用，会导致堆内存无法正确释放，导致内存泄漏

unique_ptr: 同一时刻只能有一个unique_ptr指向给定的对象，unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁

weak_ptr:  weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和->,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权. 

**如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放**



##### 解决循环引用

即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄露。

**1**. 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。

**2**. 当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A

**3**. 使用弱引用的智能指针打破这种循环引用。 weak_ptr

一个强引用当被引用的对象活着的话，这个引用也存在（就是说，当至少有一个强引用，那么这个对象就不能被释放）。share_ptr就是强引用。相对而言，弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。



#### C++内存管理

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区

- **栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
- **堆**：动态申请的内存空间，就是由 `malloc` 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。
- 全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
- **常量存储区**（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。
- **代码区**（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env



#### 函数的调用机制

（1）建立栈空间；
（2）保护现场：主调函数运行状态和返回地址入栈；
（3）为被调函数中的局部变量分配空间，完成参数传递，参数从右往左入栈；

（4）跳转到被调用的函数地址，执行被调函数函数体；
（5）释放被调函数中局部变量占用的栈空间；
（6）回复现场：取主调函数运行状态及返回地址，释放栈空间；
（7）继续主调函数后续语句。



#### C++11 新特性

- “语法糖”：`nullptr`, `auto`自动类型推导，范围for循环，初始化列表, lambda表达式等
- 右值引用和移动语义
- 智能指针
- C++11多线程编程：`thread`库及其相配套的同步原语`mutex`, `lock_guard`, `condition_variable`, 以及异步`std::furture`



##### 深拷贝与浅拷贝

 C++ 中，默认对象之间的拷贝（包括默认复制构造函数和默认赋值语句）是浅拷贝

浅拷贝就是逐个字节的拷贝。也就是说，拷贝后每一个成员变量的值都相同。如果该值是基本数据类型，那么该值被拷贝；如果该值是引用数据类型（如对象、指针等），那么该值（注意：这里的值是指**地址**）也会被拷贝。

一句话：**浅拷贝会共享引用数据类型成员变量（指针指向同一个地址），而不共享原始数据类型的成员变量**

有时候，我们并不希望拷贝对象时，其引用成员变量指向同一个引用数据类型的数据对象，而希望它们指向不同的位置，但是这些位置存储的值是相同的。这就需要用到深拷贝。

- 浅拷贝会**共享**引用数据类型成员变量（指针指向**同一个地址**），而**不共享**原始数据类型的成员变量
- 深拷贝**不会共享**引用数据类型成员变量（它们的指针指向**不同**地址，但是拷贝后指针指向地址所存储的**值是相等的**），也**不共享**原始数据类型的成员变量
- 在 C++ 中可以**自定义复制构造函数**、**重载赋值运算符**，**实现深拷贝**



##### i++是原子操作吗

不是原子操作。理由：

**1.i++分为三个阶段：**

内存到寄存器
寄存器自增
写回内存
这三个阶段中间都可以被中断分离开

```
在多线程场景中可以使用原子整型(AtomicInteger)
```



##### C++类对象从编写代码定义到生成可执行文件的全过程描述



##### 类对象的内存分布与生存周期

对于静态内存中存储的局部static对象、类static数据成员以及定义在任何函数之外的变量，全局对象(任何函数之外的对象)在程序启动时分配，在程序结束时销毁；

对于局部static对象、类static对象在第一次使用前分配内存，在程序结束时销毁。

对于栈内存，用来保存定义在函数内的非static对象。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁，分配在静态或栈内存中的对象由编译器自动创建和销毁。

对于堆内存。程序用堆来存储动态分配的对象(程序运行时分配的对象)。动态内存管理是通过一对运算符来完成的：new在动态内存中为对象分配空间并返回一个指向该内存对象的指针；delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。